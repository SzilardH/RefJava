grammar hu.elte.refjava.lang.RefJava with org.eclipse.xtext.xbase.Xbase
generate refJava "http://www.elte.hu/refjava/lang/RefJava"

import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

///////////////
// Structure //
///////////////

File:
	'package' name=QualifiedName ';'
	refactorings+=RefactoringRule*
;

RefactoringRule:
	SchemeInstanceRule | CompositeRefactoringRule
;

SchemeInstanceRule:
	 type=SchemeType 'refactoring' name=ID '('
		(parameters+=PMetaVariable (',' parameters+=PMetaVariable)*)?
	')'
		matchingPattern=Pattern
		'~'+
		replacementPattern=Pattern
	('target'
		targetPattern=Pattern)?
	((topDefinition?='top' 'level')?
	'definition'
	('in' definitionLocation=InDefinitionLocation)?
		definitionPattern=Pattern)?
	('when'
		('assignment'
			assignment=AssignmentList)?
		('precondition'
			precondition=XExpression)?
	)?
;

AssignmentList:
	assignment+=Assignment =>(';' assignment+=Assignment)* ';'?
;

Assignment:
	{Assignment} name=(PNameMetaVariable | PTypeMetaVariable | PParameterMetaVariable) '=' value=XExpression
;


enum SchemeType:
	LOCAL='local' | BLOCK='block' | LAMBDA='lambda' | CLASS='class'
;

enum InDefinitionLocation:
	CLASS='class' | SUPER='super'
;

CompositeRefactoringRule:
	'composite' 'refactoring' name=ID '('
		(parameters+=PMetaVariable (',' parameters+=PMetaVariable)*)?
	')' 'do'
		(steps+=XExpression ';')*
	('when'
		precondition=XExpression)?
;

//////////////
// Patterns //
//////////////

PMetaVariable returns PExpression:
	{PMetaVariable} '#' name=ID multi?='..'?
;

PTypeMetaVariable returns PExpression:
	{PTypeMetaVariable} 'type#' name=ID
;

PNameMetaVariable returns PExpression:
	{PNameMetaVariable} 'name#' name=ID
;

PParameterMetaVariable returns PExpression:
	{PParameterMetaVariable} 'parameter#' name=ID multi?='..'?
;

Pattern:
	(patterns+=PExpressionOrVarDeclaration =>(';' patterns+=PExpressionOrVarDeclaration)* ';'?) | empty?="-"
		// =>: local, distinguishes semicolons
;

PExpressionOrVarDeclaration returns PExpression:
	PDeclaration | PExpression
		// do not change the order -- it does matter here!
;

PDeclaration returns PExpression:
	PVariableDeclaration (
		{PMethodDeclaration.prefix=current} '(' (
			arguments+=FullJvmFormalParameter (',' arguments+=FullJvmFormalParameter)* | metaArguments=PParameterMetaVariable
		)? ')' (body=PBlockExpression)
	)?
;

PVariableDeclaration returns PVariableDeclaration:
	=>({PVariableDeclaration} ( // =>: global, see PExpressionOrVarDeclaration->...->PFeatureCall
		(visibility=Visibility | metaVisibility=PMetaVariable)? // for methods
		(type=JvmTypeReference | metaType=PTypeMetaVariable)
		(name=ValidID | metaName=PNameMetaVariable)
	)) ('=' right=PExpression)? 
;

enum Visibility:
	NULL='null' | PACKAGE='package' | PUBLIC='public' | PRIVATE='private' | PROTECTED='protected'
;

PExpression returns PExpression:
	PMemberFeatureCall
;

PMemberFeatureCall returns PExpression:
	PPrimaryExpression (
		=>({PMemberFeatureCall.memberCallTarget=current} ".")
		(feature=IdOrSuper | metaFeature=PNameMetaVariable) (
			=>'(' memberCallArguments=PParameterMetaVariable? ')' 
		)?
	)*
;

PPrimaryExpression returns PExpression
	: PConstructorCall
	| PBlockExpression
	| PFeatureCall
	| PReturnExpression
	| PTargetExpression
	| PNothingExpression
	| PMetaVariable
	| PTypeMetaVariable
	| PNameMetaVariable
	| PParameterMetaVariable
		// no explicit metavariables here to preserve structure
;

PConstructorCall returns PExpression:
	{PConstructorCall} 'new' (name=ValidID | metaName=PNameMetaVariable) //constructor=[types::JvmConstructor|QualifiedName]
	=>'(' (arguments+=PExpression (',' arguments+=PExpression)*)? ')' (
		anonInstance?='{' (elements+=PDeclaration =>(';' elements+=PDeclaration)* ';'?)? '}'
			// =>: local, distinguishes semicolons
	)?
;

PBlockExpression returns PExpression:
	{PBlockExpression} '{'
		(expressions+=PExpressionOrVarDeclaration =>(';' expressions+=PExpressionOrVarDeclaration)* ';'?)?
			// =>: local, distinguishes semicolons
	'}'
;

PFeatureCall returns PExpression:
	{PFeatureCall} (
		feature=IdOrSuper (
			=>'(' (featureCallArguments+=PExpression (',' featureCallArguments+=PExpression)*)? ')'
		)?
	) | (
		metaFeature=PMetaVariable
			=>'(' (featureCallArguments+=PExpression (',' featureCallArguments+=PExpression)*)? ')'
	)
;

PReturnExpression returns PExpression:
	{PReturnExpression} 'return' (->expression=PExpression)?
;

PTargetExpression returns PExpression:
	{PTargetExpression} 'target'
;

PNothingExpression returns PExpression:
	{PNothingExpression} 'nothing'
;

///////////////////
// Preconditions //
///////////////////

// adds metavariable references
@Override
XPrimaryExpression returns xbase::XExpression
	: XConstructorCall
	| XBlockExpression
	| XSwitchExpression
	| XSynchronizedExpression
	| XFeatureCall
	| XLiteral
	| XIfExpression
	| XForLoopExpression
	| XBasicForLoopExpression
	| XWhileExpression
	| XDoWhileExpression
	| XThrowExpression
	| XReturnExpression
	| XTryCatchFinallyExpression
	| XParenthesizedExpression
	| MetaVariable
	| TargetExpression
	| TypeMetaVariable
	| NameMetaVariable
	| ParameterMetaVariable
;

MetaVariable returns xbase::XExpression:
	{MetaVariable} '#' name=ID multi?='..'?
;

TypeMetaVariable returns xbase::XExpression:
	{TypeMetaVariable} 'type#' name=ID
;

NameMetaVariable returns xbase::XExpression:
	{NameMetaVariable} 'name#' name=ID
;

ParameterMetaVariable returns xbase::XExpression:
	{ParameterMetaVariable} 'parameter#' name=ID multi?='..'?
;

TargetExpression returns xbase::XExpression:
	{TargetExpression} 'target'
;

@Override
XSetLiteral returns xbase::XSetLiteral:
	{xbase::XSetLiteral} '@' '{' (elements+=XExpression (',' elements+=XExpression )*)? '}'
;

@Override
XListLiteral returns xbase::XListLiteral:
	{xbase::XListLiteral} '@' '[' (elements+=XExpression (',' elements+=XExpression )*)? ']'
;

// removes '..'
@Override
OpOther
	: '=>'
	| '>' (=>('>' '>') | '>')
	| '<' (=>('<' '<') | '<' | '=>')
	| '<>'
	| '?:'
;

// removes '#'
@Override
terminal HEX:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+
	('@' (('b'|'B')('i'|'I') | ('l'|'L')))?;
